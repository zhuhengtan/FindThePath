# FindThePath 开发计划（技术方案 + 里程碑）

本文档面向开发落地，描述 FindThePath（旋转地块连通路径 + 断路自动掉头）的模块拆分、数据结构、关卡生成与可解性校验、以及云端存储/云函数的接口草案。

## 1. 目标与范围

### 1.1 MVP（首版可发布）

- 单车玩法：点击地块顺时针旋转 90°，连接路径到达终点
- 断路不失败：车辆在路径尽头检测下一格入口不匹配则 180° 掉头
- 不允许暂停：玩家可通过 Soft-lock（单格/短段往返）实现等待与思考
- 不允许“车在格上旋转”：车辆位于某格时，该格不可旋转
- 失败条件：耗尽步数上限（旋转次数）；不引入陷阱与撞车
- 关卡来源：按 level 层数程序化生成，数据存云端（开发期可本地生成）

### 1.2 后续迭代（非 MVP）

- 时间上限（与步数上限二选一优先，后期可叠加）
- 单向地块、周期闸门/激光（尽量做“可预告”的节奏机关）
- 多车与撞车（作为额外章节，不进入主线早期）
- 激励广告道具：加步数/加时、提示一步、撤销一次旋转

## 2. 技术栈与工程约定

- 引擎：Cocos Creator 3.8.7
- 语言：TypeScript
- 代码组织：遵循仓库模块化结构，基础设施优先复用现有模块
  - hunter：事件、存储、时间、配置加载
  - hunter-ui：弹窗、toast、通用 UI 组件
- 资源加载：优先使用 Asset Bundle（main-game bundle 已存在）
- 关卡可复现：所有程序化关卡必须由 seed + generatorVersion 唯一确定

## 3. 目录规划（建议）

在现有 `assets/main-game/` 内新增 FindThePath 相关目录，避免与模板/对话系统耦合：

```
assets/main-game/
  scenes/
  scripts/
    find-the-path/
      core/              # 规则、数据结构、方向/连通判定
      runtime/           # 关卡运行时：加载、生成、回放
      view/              # 关卡表现：地块、车辆、特效、UI
      services/          # 云端接口、缓存、本地 mock
      debug/             # 调试面板、可解性校验工具入口
```

## 4. 核心玩法系统设计

### 4.1 网格与地块连通（Tile Graph）

关键目标：让“连接规则”完全确定且可用于三处复用：

- 运行时车辆移动判定
- 关卡生成后的可解性校验
- 调试回放（输入序列重放）

建议用“方向位”表示连通（bitmask），避免到处写 if/else。

- 方向定义：Up / Right / Down / Left（0,1,2,3）
- 连接表示：`mask`（4 bit），例如 Up+Down = 0b0101
- 旋转：顺时针 +90° 等价于 mask 进行位移（循环移位）

地块类型（不含旋转）建议定义为基础 mask：

- I：Up+Down
- L：Up+Right
- T：Up+Right+Left
- X：Up+Right+Down+Left
- 单向（后期）：可扩展为“允许进入方向集合 + 允许离开方向集合”

### 4.2 车辆移动与掉头（No-Fall U-Turn）

规则边界（与你当前设定对齐）：

- 不允许暂停
- 不允许在车辆位于某格时旋转该格
- 断路永不直接失败，失败来自资源耗尽（步数/时间）

判定建议统一为“离散节点判定”（避免浮点边界带来的随机感）：

- 车辆在格子中心与边缘节点之间匀速移动
- 到达“离开当前格子的边缘节点”时执行下一步判定
  - 若下一格存在且入口连通：进入下一格（方向不变）
  - 否则：立即执行 180° 掉头（方向反转），返回上一节点

表现层可以做“漂移/掉头”动画，但逻辑层应当瞬时完成方向反转，以保持可预测与可复现。

### 4.3 输入与旋转限制（Click-to-Rotate）

点击一个地块：

- 前置校验：
  - 该格当前无车辆占用
  - 步数剩余 > 0
  - 关卡未结束
- 逻辑执行：旋转 +90°，步数 -1
- 表现执行：0.1s tween 旋转动画
- 生效时机：旋转对“下一次离开节点的判定”生效（不回溯影响已发生的移动）

### 4.4 胜负与结算

- 胜利：车辆进入终点格（或到达终点节点）
- 失败（MVP）：步数耗尽且未通关
- 失败（后续可选）：时间耗尽；陷阱触发；撞车
- 结算：只需要“通关/失败”，不做三星

### 4.5 HUD 与信息提示（超休闲可读性）

MVP 必备信息：

- 剩余步数
- 当前关卡层数
- 明确的起点/终点标识

后续可选（用于降低误操作成本）：

- 点击前预览：该格旋转后连通方向的箭头/高亮
- 1~2 格预测：车辆下一步将进入的格子提示（仅提示，不自动解）

## 5. 关卡数据结构（建议 JSON）

### 5.1 LevelKey（可复现标识）

- `level`: number
- `seed`: string
- `generatorVersion`: string

推荐策略：

- `seed = hash(level + ":" + generatorVersion)`
- 云端只要返回 `generatorVersion` 和 `level`，客户端也能生成；或云端直接返回完整关卡数据（便于热修/活动关）
- 目前采用客户端本地生成的方式，难度随 level 增加而增加

### 5.2 LevelData（运行时输入）

```json
{
  "level": 12,
  "generatorVersion": "v1",
  "seed": "a1b2c3",
  "width": 6,
  "height": 6,
  "start": { "x": 0, "y": 0, "dir": "Right" },
  "goal": { "x": 5, "y": 5 },
  "stepLimit": 12,
  "timeLimitMs": 0,
  "tiles": [
    { "x": 0, "y": 0, "type": "L", "rot": 1 },
    { "x": 1, "y": 0, "type": "I", "rot": 0 }
  ],
  "blocks": [
    { "x": 3, "y": 2 }
  ],
  "extras": {}
}
```

字段约定：

- `rot`: 0/1/2/3 表示 0/90/180/270（顺时针）
- `blocks`: 不可通行格（可选），用于生成器塑形
- `timeLimitMs`: MVP 固定为 0；后续启用

## 6. 程序化关卡生成（Infinite Levels）

### 6.1 生成目标

- 可无限扩展：level -> 参数 -> 关卡
- 难度可控：主要通过 `stepLimit` 与“必须 soft-lock 等待”的结构引导
- 可复现：同一个 (level, generatorVersion) 必定生成同一关卡
- 可验证：每关生成后必须通过可解性校验才可发布/下发

### 6.2 难度参数随层数变化（建议）

- 地图尺寸：
  - 1-10：4x4 或 5x5
  - 11-30：6x6
  - 31+：7x7 或 8x8
- 步数上限：
  - 前期宽松：允许“乱转也能过”
  - 中后期收紧：接近最优解旋转数 + 余量
- 机关（后续）：
  - 先上单一周期闸门，再叠加单向地块，再考虑多车

### 6.3 生成流水线（云端/本地一致）

1. 依据 level 计算参数（width/height/复杂度目标/stepLimit 期望）
2. 用 seed 初始化 RNG，生成 tiles 初始布局与旋转
3. 运行可解性校验
4. 不可解则重试（同 seed 不重试，需 seed 派生重试次数：seed' = hash(seed + ":" + attempt)）
5. 通过后保存/下发 LevelData（或保存 seed + version）

## 7. 可解性校验（Solvability Check）

### 7.1 为什么必须做

程序化生成 + 步数限制，一旦出现“不可解关卡”，用户会直接流失；因此校验必须是生成器的一部分，而不是上线后的“人工抽检”。

### 7.2 校验口径（以规则为准）

校验逻辑必须与运行时完全一致：

- 同样的掉头规则
- 同样的“车在格上不可旋转”限制
- 同样的旋转步数消耗与上限

### 7.3 搜索策略（MVP：单车 + 步数限制）

推荐最小可用策略：

- 状态定义（建议）：
  - 所有 tile 的 `rot`（可压缩成字符串/位数组）
  - 车辆位置与方向（所在格 + 当前朝向 + 当前节点类型）
  - 已用步数（或剩余步数）
- 行为：
  - 旋转某个“非占用格”的 tile（+1 步）
  - 自动推进车辆直到下一个判定节点（不计步数）
- 搜索：
  - BFS 按步数层级扩展，找到任意到达 goal 的解即通过
  - 设最大扩展节点数上限（例如 50k/100k），避免云函数超时；超出则判定“生成失败重试”

输出建议：

- `minStepsToWin`：最小旋转次数（用于设置 stepLimit）
- `oneSolution`：一条旋转序列（用于调试重放与关卡回归）

## 8. 云端方案（云函数 + 存储）

### 8.1 存储策略（推荐：存 key 而非全量）

推荐默认只存：

- `level`
- `generatorVersion`
- `seed`
- 以及生成参数的版本（可合并进 generatorVersion）

当需要做“活动关/热修关”时，再额外存完整 `LevelData` 覆盖默认生成结果。

### 8.2 云函数接口草案

#### getLevel

- 入参：`level`, `clientVersion`
- 出参：
  - 若该 level 有覆盖关卡：返回完整 `LevelData`
  - 否则：返回 `{ level, seed, generatorVersion }`（客户端生成）

#### reportResult

- 入参：`level`, `win`, `usedSteps`, `usedTimeMs`, `generatorVersion`, `seed`
- 用途：统计难度、调整生成参数（不影响单局逻辑）

### 8.3 客户端缓存

- 本地缓存最近 N 关的 `{levelKey, levelData}`，减少网络抖动
- 可通过 `StorageManager` 存储

## 9. 里程碑与交付物（建议按模块推进）

### M1：核心规则与单关可玩（目标：可手工配置关卡）

- Tile 数据结构与旋转连通判定
- 车辆移动与掉头
- 点击旋转 + 占用格不可旋转
- HUD（步数、关卡号、重开）

交付：给定 LevelData 能稳定通关/失败，逻辑可复现。

### M2：程序化生成（本地）+ 可解性校验

- level -> seed -> LevelData 生成器
- BFS 校验器输出 minSteps 与解序列
- 自动设置 stepLimit（minSteps + 余量）

交付：level 连续增长可玩且无不可解关卡。

### M3：云端接入 + 发布准备

- getLevel / reportResult 接入
- 本地缓存与降级（断网可用最近缓存关）
- 广告道具（可选）：加步数 / 提示一步 / 撤销一次

交付：线上可无限关卡，数据可回收调参。

## 10. 验收清单（MVP）

- 规则一致性：运行时与校验器对同一关卡结论一致
- 可复现：同一 levelKey 在不同设备生成一致
- 无软锁死局：允许 soft-lock 等待，但不会出现“必然无法到终点”的生成关
- 体验：前 10 关无阅读成本，乱转也能过；中后期逐步收紧步数形成挑战
